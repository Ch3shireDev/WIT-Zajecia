big-endian (motorola, RISC)   adr:2000h =0x6F        adr:2001h =0x45  adr:2002h =0x7C       adr:2003h =0x8A Instrukcja arytm.wyst. z częst. 38% CPI instr.arytm.=1 Instr.przesłań wyst.z częst. 49%  CPI instr.przesłań =1,5 CPI pozostałych instrukcji 2,4 CPI procesora = (38%*1)+(49%*1,5)+(13%*2,4) Fracenh = 0,49                       Speedup = CPIorg/CPInew Lattency =  5*(90+20) = 5*110 = 550ps Throughput = 1000/(90+20) GOPS a)RAW  mov cx,[bx]   mov ax,1075                  add ax,cx       mov ds.,ax b)WAW mov bx,b7a4h   mov ax,[mem]                add bx,cx           mov ax,bx c)WAR  mov bx, ax                      mov ax, cx Tryb adresowania: a) pośredni  mov ax,[bx]  b) względne mov ax,[di+200h]   mov di,set[bx]        mov away[si],bl c) rejestracyjny mov ax,dx   d) bezpośredni mov ax,var5 <-zmienna e) natychmiatowy mov ax,700h <-wartość f) bazowo-indexowy mov dx,[bx + di] g) względne b-i mov dh,[bx+di+20h]    mov ax, file[di+bx] Architektura CISC
- architektura ISA
- procesor wykorzystujący bogaty zestaw (listę) instrukcji i liczne sposoby adresowania argumentów; charakterystyczną cechą jest zróżnicowana długość instrukcji (w bajtach) i czas ich wykonania Architektura RISC (np. PowerPC)
- procesor wykorzystujący niewielki zbiór elementarnych rozkazów o zunifikowanej długości i takim samym czasiewykonania. EPIC 
- (ITANIUM) 
-Zwielokrotnione jednostki wykonawcze
-Równoległe wykonanie instrukcji
-Duża liczba rejestrów, zestaw prostych, ortogonalnych instrukcji 
-Ciężar optymalizacji wykonania przeniesiony na kompilator Załużmy, że rejestr segmentu DS. procesora Pentium zawiera liczbę 614Ch. a)określ fizyczny adres użyty do zaadresowania drugiego argumentu instrukcji          mov ah,[bx] jeśli rejestr bx zawiera liczbę 21A7h i jest włączony tryb adresów rzeczywistych x86(real-addres-mode) adres fizyczny= 614C0+21A7=63667 h b)określ fizyczny adres używany do zaadresowania drugiego argumentu w instrukcji      mov ah,[300FA4125h] jeśli deskrypt segmentu wskazywany przez DS. w polu adresu bazowego zawiera liczbę 220F11A6h i jest włączona stanadardowa segmentacja adres fizyczny =300FA4125+220F11A6 h 

zadanie na obliczanie CPI procesora. Instrukcja arytm.. wyst. Z częst. 38% CPI instr. Arytm. = 1 Instr. Przesłań wyst. Z częst. 49% CPI instr. Przesłań = 1,5 CPI pozostałych instrukcji 2,4 CPI procesora = (38%*1)+(49%*1,5)+(13%*2,4) 

Aby określić wydajność komputera należy zmierzyć czas wykonania programu testowego (benchmark)
- Aby obliczyć czas wykonania należy znać czas trwania cyklu CPU (z danych katalogowych CPU) oraz łączną liczbę cykli CPU dla danego programu
- Aby oszacować liczbę cykli CPU w programie należy znać liczbę instrukcji w programie oraz przeciętną wartość CPI (average CPI)
- W profesjonalnych badaniach wydajności komputerów wykorzystuje się pomiar czasu wykonania rzeczywistych programów najlepiej jest użyć typowych aplikacji, które będą wykonywane przez system podczas normalnej eksploatacji lub wykorzystać klasy aplikacji, np. kompilatory, edytory, programy obliczeń numerycznych, programy graficzne itp.
- Krótkie programy testowe (benchmarks) wygodne dla architektów i projektantów łatwe w standaryzacji testów SPEC (System Performance Evaluation Cooperative) producenci sprzętu uzgodnili zestawy programów testowych (benchmarków) wartościowe wyniki do oceny wydajności komputerów i jakości kompilatorów
- Prawo Amdahla Określa współczynnik poprawy wydajności Speed up w rezultacie ulepszenia systemu komputerowego
- Koncepcja von Neumana  Jednostka logiczna Pamięć niedzielona programu i danych
- Koncepcja typu Harvard Jednostka logiczna Pamięć programu Pamięć danych
- W procesorach typu PENTIUM zastosowano wewnątrz procesora pamięć podręczną typu CASCHE, co znacznie przyspieszyło działanie układu. Mimo iż pamięć ta ma znacznie mniejszą pojemność od RAM`u jest od niej o wiele szybsza (zasada przyspieszenia kosztem ograniczenia pojemności). W pamięci podręcznej przechowywane są instrukcje następujące po aktualnie wykonywanej. W przypadku gdy są to instrukcje bezpośredniego następstwa wzrost prędkości jest nieznaczny, jednak w przypadku następujących po sobie iteracji widać już znaczne przyspieszenie. Wynika to z tego, że przyrost szybkości jest liniowy względem ilości wykonywanych w jednej instrukcji operacji elementarnych: 4 instrukcje bezpośredniego następstwa 
- przyrost efektywności o 4 jednostki. 4 iteracje po 1000 powtórzeń każda 
- przyrost efektywności o 4000 jednostek
- Klasa PENTIUM 2, PENTIUM 3, PENTIUM 4:W procesorach tego typu zastosowano architekturę podobną do PENTIUM, z tym że rozszerzano pojemność rejestrów, aż do 128 bitów (PENTIUM 4), co daje możliwość uzyskania aż na 64 bitowego słowa instrukcji.Technologia VLIW (Very Long Instruction Word) 
- długie słowa instrukcji.
- Klasa PENTIUM PRO: Procesory tej klasy to procesory typu RISC z wbudowaną emulacją CISC, dla zachowania zgodności z innymi modelami procesorów firmy INTEL. Aby przyspieszyć pracę dekodera instrukcji wykorzystano w nim trzy układy dekodujące instrukcje równolegle (czyli trzy instrukcje dekodowane w jednym kroku pracy). Klasa PENTIUM MMX: Procesory MMX mają architekturę podobną do innych procesorów PENTIUM lecz wzbogacone zostały o szereg nowych instrukcji (zgodnie z koncepcją CISC) wspomagających działania multimedialne. Klasa AMD Kx: Procesory AMD oparte są na architekturze podobnej koncepcjami do architektury PENTIUM. W klasie tej pojawiły się także procesory analogiczne do PENTIUM MMX
- z rozszerzoną listą instrukcji wspomagania grafiki trójwymiarowej 3D NOW!.
- Wykorzystanie rejestrów w czasie wykonywania programu. Przed użyciem programu zapisanego w języku wysokiego poziomu, musi nastąpić jego kompilacja do języka adresowego 
- tzw. asemblera, będącego znakowym odpowiednikiem kodu maszynowego. Gdy tak już się stanie program może zostać wykonany przez procesor.
- NKB 
- naturalny kod binarny (np.: 12 to 1100) U1 
- kod uzupełnień do jedynki (np.: 12 to nie 1100 tylko 0.0011
- dodajemy 0(dla +) i 1(dla -)) U2 
- kod uzupełnień do dwóch (np.: 12 to nie 1100 tylko 0011 + 0001 czyli 0100 i dodajemy 0(dla +) i 1(dla -) 
- czyli otrzymujemy, że 12 = 0.0100) BCD 
- kod dwójkowo dziesiętny (przyporządkowuje cyfrom od 0 do 9 czterocyfrowe wektory binarne: 275 to 2
- 7- 5, czyli 0010 0111 0101) BIAS 
- kod baza (Abase = A + BASE, czyli np:
-127 w kodzie Abase ma postać: Abase =
-127 + (128) = 00000001) HEX 0-F 0000->1111
- Pipelining nie zmienia czasu wykonania pojedynczej instrukcji (latency), wpływa natomiast na czas wykonania ciągu instrukcji (throughput) Częstość z jaką pracuje potok jest ograniczona przez czas pracy najwolniejszego stopnia w potoku (slowest pipeline stage) Wiele instrukcji jest wykonywanych równolegle (instruction level parallelism) Potencjalne zwiększenie wydajności jest tym większe, im większa jest liczba stopni w potoku Duże zróżnicowanie czasu trwania operacji w poszczególnych stopniach ogranicza wzrost wydajności Czas potrzebny na napełnienie potoku i opróżnienie go ogranicza wzrost wydajności
- Równoległe przetwarzanie instrukcji w potoku prowadzi często do niekorzystnych zjawisk nazywanych hazardem. Hazard polega na braku możliwości wykonania instrukcji w przewidzianym dla niej cyklu. Wyróżnia się trzy rodzaje hazardu:1. Hazard zasobów (structural hazard) 
- kiedy dwie instrukcje odwołują się do tych samych zasobów 2. Hazard danych (data hazard) 
- kiedy wykonanie instrukcji zależy od wyniku wcześniejszej, nie zakończonej jeszcze instrukcji znajdującej się w potoku 3. Hazard sterowania (control hazard) 
- przy przetwarzaniu instrukcji skoków i innych instrukcji zmieniających stan licznika rozkazów (np. wywołania podprogramów) Hazard sterowania został omówiony już wcześniej 
- teraz zajmiemy się hazardem zasobów i danych
- Podstawowym sposobem rozwiązywania problemów wynikających z hazardu jest chwilowe zatrzymanie potoku na jeden lub więcej cykli zegara. W tym celu do potoku wprowadza się tzw. przegrody (stalls), które są faktycznie operacjami pustymi ("bubbles") Przegrody wpływają oczywiście na zmniejszenie wydajności CPU Ze względu na występowanie zjawisk hazardu rzeczywista wydajność CPU jest zawsze mniejsza od wydajności teoretycznej, obliczonej przy założeniu że hazardy nie występują
- Nazywany też hazardem strukturalnym lub konfliktem zasobów (resource conflict)  Powodem hazardu tego typu jest jednoczesne żądanie dostępu do tego samego zasobu (zwykle pamięci) przez dwa różne stopnie potoku Typowy hazard zasobów występuje, gdy jedna z instrukcji wykonuje ładowanie danych z pamięci podczas gdy inna ma być w tym samym cyklu ładowana (instruction fetch) Rozwiązanie polega na wprowadzeniu jednej (lub kilku przegród). W efekcie wzrasta CPI i spada wydajność procesora
- Hazard danych występuje, ponieważ potok zmienia kolejność operacji odczytu/zapisu argumentów w stosunku do kolejności, w jakiej te operacje występują w sekwencyjnym zapisie programu Instrukcja mov cx,ax ma pobrać zawartość akumulatora ax, podczas gdy potok jeszcze nie określił tej zawartości w poprzedniej instrukcji dodawania Hazard RAW (read after write) występuje gdy pojawi się Sądanie odczytu danych przed zakończeniem ich zapisu Instrukcja mov cx,ax ma pobrać zawartość akumulatora ax, podczas gdy potok jeszcze nie określił tej zawartości w poprzedniej instrukcji dodawania add ax,bx | mov cx,ax
- Hazard WAR (write after read) występuje gdy pojawi się żądanie zapisu danych przed zakończeniem ich odczytu CPU chce zapisać do akumulatora ax nową wartość równą sumie ax+cx, podczas gdy instrukcja przesłania mov jeszcze nie odczytała starej zawartości ax i nie przesłała jej do rejestru bx np. mov bx,ax | add ax,cx
- Hazard WAW (write after write) występuje gdy pojawi się żądanie zapisu danych przed zakończeniem wcześniejszej operacji zapisu CPU chce zapisać do akumulatora ax nową wartość równą sumie ax+bx, podczas gdy poprzednia instrukcja nie zdążyła jeszcze pobrać do ax zawartości komórki pamięci [mem] np. mov ax,[mem] | add ax,bx
- Funkcje i właściwości stosu Stos jest pamięcią typu LIFO (last-in-first-out) Typowe zastosowania stosu przy wywołaniu podprogramu zapamiętuje adres powrotu do programu głównego przy przejściu do programu obsługi przerwania zapamiętuje adres powrotu do przerwanego programu służy do chwilowego przechowywania zawartości rejestrów w celu uwolnienia ich do innych zadań może być użyty do przekazywania parametrów do podprogramów Programista musi dbać o zbilansowanie liczby operacji zapisu i odczytu oraz o zachowanie właściwej kolejności zapisu i odczytu (odczyt wartości przebiega w odwrotnej kolejności niż przy zapisie) Programista musi dbać o to, by stos nie rozrósł się nadmiernie i nie przekroczył limitu pamięci (stack overflow) 
- częsty błąd w przypadku programów rekurencyjnych lub przy wystąpieniu nieskończonej pętli
- Rejestry Niewielka pamięć robocza CPU do przechowywania tymczasowych wyników obliczeń Liczba rejestrów i ich funkcje różnią się dla różnych procesorów Rejestry mogą pełnić rozmaite funkcje: Rejestry ogólnego przeznaczenia (GP 
- general purpose) Rejestry danych (np. akumulator) Rejestry adresowe Rejestr wskaźników (stanu, warunków, flag) Architektura oparta na rejestrach GP jest bardzie elastyczna przy programowaniu, ale procesor jest bardziej złożony a czas wykonania rozkazu dłuższy Architektura oparta na specjalizowanych rejestrach upraszcza budowę procesora i przyspiesza wykonanie rozkazu, ale ogranicza programistę 