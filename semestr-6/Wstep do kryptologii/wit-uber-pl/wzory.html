<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Wzory</title>

</head>

<body bgcolor="#000000" text="#FFFFFF">
<font size="2">
<h1>Diffi Helman  </h1>
<ul>
  <li>Alicja i Bob w dowolny sposób wybierają dwie liczby względnie pierwsze:  dużą liczbę p oraz liczbę g, będącą generatorem grupy multiplikatywnej Z<sub>p</sub>*.</li>
  <li> Alicja losuje liczbę a; Bob losuje liczbę b</li>
  <li> Alicja wysyła Bobowi <strong>g<sup>a</sup> mod p</strong> ; Bob wysyła Alicji <strong>g<sup>b</sup> mod p</strong><br />
    <strong>k = (g<sup>b</sup>)<sup>a</sup> mod p</strong> <br />
  </li>
</ul>
<h1>RSA</h1>
<h2>Generowanie kluczy</h2>
<ul>
  <li>
  Wybieramy losowo dwie duże liczby pierwsze p i q </li>
  <li>    Obliczamy wartość n = p*q</li>
  <li>    Obliczamy:  φ(n) = (p-1)*(q-1)</li>
  <li> Wybieramy liczbę e (1 &lt; e &lt; φ(n)) względnie pierwszą z φ(n)</li>
  <li> Znajdujemy liczbę d odwrotną do e mod φ(n): d = e<sup>-1</sup> mod φ(n)<br />

  </li>
</ul>
<strong>Klucz publiczny</strong> jest definiowany jako para liczb (n, e), <br /> natomiast <strong>kluczem prywatnym</strong> jest para (n, d).<br />
  
<h2>Szyfrowanie i deszyfrowanie</h2>

<p>Zanim zaszyfrujemy wiadomość, dzielimy ją na bloki m<sub>i</sub> o wartości liczbowej nie większej niż n, a następnie każdy z bloków szyfrujemy według wzoru: <br />
  <strong>c<sub>i</sub> = m<sub>i</sub><sup>e</sup> mod n</strong><br />
<br />
  
  Zaszyfrowana wiadomość będzie się składać z kolejnych bloków c<sub>i</sub>. Tak stworzony szyfrogram przekształcamy na tekst jawny, odszyfrowując kolejne blok ci według wzoru:<br />
<strong>m<sub>i</sub> = c<sub>i</sub><sup>d</sup> mod n </strong>
<h2>Podpis RSA</h2>
<h3>Generacja</h3>
<ul>
  <li>  H(m) - skrót wiadomości
    
  </li>
  <li>h = H(M)</li>
  <li>s=h<sup>d</sup>mod n</li>
</ul>
<h3>Weryfikacja</h3>
  <ul>
  <li>  h<sub>1</sub> = H(m')
    
  </li>
  <li>h<sub>2</sub> = S<sup>e</sup>mod n</li>
  <li>Jeżeli h<sub>1</sub> = h<sub>2</sub> to OK</li>
</ul>
<h1>ElGamal </h1>

<h2>Generowanie klucza</h2>
<p> wybieramy dowolną liczbę pierwszą <em>p</em>, dowolny generator α podgrupy multiplikatywnej, tzn. taki element, którego rząd  jest równy <em>p</em> − 1, oraz dowolne <em>k</em> takie, że: 1 &lt; <em>t</em> &lt; <em>p</em>. Liczymy β:</p>
<p>β = α<sup>t</sup> mod p</p>
<p>Następnie publikujemy k<sub>1</sub> = (<em>p</em>,α,β) jako<strong> klucz publiczny</strong> i zachowujemy k<sub>2</sub> = (<em>p</em>, <em>t</em>) jako<strong> klucz prywatny.</strong></p>
<h2>Szyfrowanie i deszyfrowanie</h2>
<p><strong>Szyfrowanie</strong>: mając do zaszyfrowania wiadomość<em>x</em>, przedstawiamy ją jako element grupy [1 &lt; <em>x</em> &lt; <em>p</em> − 1] wybieramy losowo liczbę<em> r </em>i liczymy (modulo <em>p</em>)</p>
<p><strong>C=(Y<sub>1</sub>, Y<sub>2</sub>) = (α<sup>r</sup>mod p, x * β<sup> r</sup> mod p</strong>)</p>

<p><strong>Deszyfrowanie</strong>: </p>
<p><strong>D<sub>k<sub>2</sub></sub>(Y<sub>1</sub>, Y<sub>2</sub>)= Y<sub>2</sub> * (Y<sub>1</sub><sup>t</sup>)<sup>-1</sup>mod p = y<sub>2</sub>*Y<sub>1</sub><sup>p-1-t</sup>mod p</strong></p>
<h2> Podpis cyfrowy </h2>
<p>Klucz jest generowany w ten sam sposób.</p>
<ul>
  <li>h = H(m) - skrot wiadomości</li>
  <li> losujemy liczbę <em>r</em> 1 &lt; r &lt; p-1 oraz gcd (r, p-1) = 1</li>
  <li>u = α<sup>r</sup>mod p</li>
  <li>obliczamy r<sup>-1</sup> mod (p-1)</li>
  <li>s =  r<sup>-1</sup> * (h - t* u) mod (p-1)</li>
  <li>podpisem jest para m = (u, s)</li>
</ul>
<p>Żeby zweryfikować podpis:</p>
<ul>
  <li>otrzymujemy wiadomosc oraz u' i s'</li>
  <li>wyznaczć skrot h' wiadomosci</li>
  <li>f = α<sup>h'</sup> mod p</li>
  <li>g = β<sup>u'</sup> * (u')<sup>s'</sup> mod p</li>
  <li>jesli f = g to OK</li>
</ul>

<h1>DSA</h1>
<h2>Generacja kluczy</h2>

<ul>
  <li>wybrać liczbę pierwszą p o dlugości L bitow (512 &lt;= L &lt;=1024) i jest wielokrotnością 64: <br/>
  2<sup> 511 + 64t</sup> < p < 2 <sup>512 + 64t </sup>, 0 <= t <= 8</li>
  <li>Wybrać liczbę oierwszą q o dlugości 160 bitow ktora dzieli liczbę p-1<br/> 
    2<sup>159</sup>< q &lt; 2<sup>160</sup>, q| (p-1)
    <ul>
      <li>Wybrać liczbę α ∈ Z<sub>p</sub><sup>*</sup> i obliczyć g = α<sup>(p-1)/q</sup></li>
      <li>jesli g = 1 to, szukać innej α</li>
      </ul>
  <li>wybrać losowo liczbę x taką, że 1 <= x <= q-1</li>      
  <li>obliczyć y = g<sup>x</sup> mod p   </li>         
  </ul>

<p>  <strong>klucze: publiczny k<sub>1</sub> = (p, q,g,y) prywatny k <sub>2</sub> = (p,q,g,x)
  </strong>
 
</p>
<h2>Generacja podpisu</h2>
<ul>
  <li>wybrać losową, tajną liczbę calkowitą: 0 &lt; k &lt; q</li>
  <li>Obliczyć r = (g<sup>k</sup> mod p ) mod q</li>
  <li>Obliczyć s = [k<sup>-1</sup>(h(m) + x * r)] mod q</li>
  <li><strong>Podpisem cyfrowym jest para liczb (r,s)</strong></li>
</ul>
<h2>Weryfikacja podpisu</h2>

<ul>
  <li>obliczyć w = s <sup>-1</sup> mod q</li>
  <li>obliczyć u<sub>1</sub> = w * h(m) mod q </li>
  <li>obliczyć u<sub>2</sub> = r * w mod q</li>
  <li>v = [(g<sup>u1</sup> * y <sup>u2</sup>)mod p] mod q</li>
  <li>Jezlei v = r to OK</li>
</ul>
</font>
</body>
</html>
